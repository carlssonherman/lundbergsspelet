<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lussekaos på Lundbergs</title>

  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes">

  <!-- Silkscreen font -->
  <link href="https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&display=swap" rel="stylesheet">

  <style>
    /* Fullscreen mobile fix */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
      touch-action: none;
      background: #000;
      position: fixed;
      inset: 0;
      font-family: 'Silkscreen', monospace;
      color: #fff;
    }

    /* Disable text selection & touch callouts everywhere */
    * {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    #game-container {
      position: fixed;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    canvas {
      display: block;
      image-rendering: pixelated;
      touch-action: none;
    }

    /* Black overlay for background tone-in */
    #bg-fade {
      position: fixed;
      inset: 0;
      background: #000;
      z-index: 5;
      pointer-events: none;
      opacity: 1;
      transition: opacity 1.5s ease-out;
    }
    #bg-fade.hidden {
      opacity: 0;
    }

    /* HUD */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 8px 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
      z-index: 20;
      text-shadow: 0 0 4px #000;
      font-size: 14px;
    }

    #score {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    #score img, #lives img {
      height: 18px;
      image-rendering: pixelated;
    }

    #lives {
      display: flex;
      gap: 4px;
    }

    /* Screens */
    .screen {
      position: fixed;
      inset: 0;
      display: none;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 25;
    }

    .screen-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      transform: translateY(-17vh);
    }

    /* Logo */
    #start-logo .logo-image {
      width: 70vw;
      max-width: 380px;
      image-rendering: pixelated;

      /* animation initial state */
      opacity: 0;
      -webkit-clip-path: inset(0 100% 0 0);
      clip-path: inset(0 100% 0 0);
    }

    /* Logo reveal when body has .logo-anim */
    body.logo-anim #start-logo .logo-image {
      animation: logoReveal 0.4s ease-out forwards;
    }

    @keyframes logoReveal {
      0% {
        opacity: 1;
        -webkit-clip-path: inset(0 100% 0 0);
        clip-path: inset(0 100% 0 0);
      }
      100% {
        opacity: 1;
        -webkit-clip-path: inset(0 0 0 0);
        clip-path: inset(0 0 0 0);
      }
    }

    /* Intro text */
    #start-intro-text {
      max-width: 320px;
      font-size: 18px;
      line-height: 1.3;
      text-shadow: 0 0 4px #000;
      margin-bottom: 16px;
      display: none;
    }

    #start-intro-text .intro-line {
      opacity: 0;
      margin: 6px 0;
      transition: opacity 0.6s ease-out;
    }

    #start-intro-text .intro-line.visible {
      opacity: 1;
    }

    /* Universal font */
    button,
    .player-choice span {
      font-family: 'Silkscreen', monospace !important;
      text-transform: uppercase;
    }

    /* Buttons */
    #start-btn,
    #message button {
      margin-top: 20px;
      padding: 10px 24px;
      border: 2px solid #fff;
      background: rgba(0,0,0,0.7);
      color: #fff;
      border-radius: 6px;
      font-size: 18px;
      cursor: pointer;
    }

    /* Start button animation */
    #start-btn {
      opacity: 0;
    }
    #start-btn.show {
      animation: startBtnFade 0.2s ease-out forwards;
    }

    @keyframes startBtnFade {
      from {
        opacity: 0;
        transform: translateY(6px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Player select */
    #select-title {
      font-size: 22px;
      margin-bottom: 16px;
      text-shadow: 0 0 6px #000;
    }

    .player-options {
      display: flex;
      gap: 24px;
      align-items: flex-end; /* bottom-align players */
    }

    .player-choice {
      background: none;
      border: none;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0;
    }

    .player-choice img {
      width: 25vw;          /* scales with viewport width */
      max-width: 140px;     /* cap at old size */
      height: auto;         /* keep aspect ratio */
      image-rendering: pixelated;
    }

    .player-choice span {
      margin-top: 6px;
      font-size: 18px;
      color: #ffffff !important;
      text-shadow: 0 0 4px #000;
    }

    /* Player Select Fade-In */
    #select-screen {
      opacity: 0;
      transition: opacity 0.6s ease-out;
    }
    #select-screen.visible {
      opacity: 1;
    }

    /* Game over message text */
    #message-text {
      font-size: 18px;
      text-shadow: 2px 2px 0 #000;
    }

  </style>
</head>
<body>

  <div id="game-container">
    <canvas id="game"></canvas>
  </div>

  <!-- Background fade overlay -->
  <div id="bg-fade"></div>

  <!-- HUD -->
  <div id="overlay">
    <div id="score">
      <img src="gfx-lussekatt.png">
      <span id="score-number">0</span>
    </div>
    <div id="lives"></div>
  </div>

  <!-- Start screen -->
  <div id="start-screen" class="screen">
    <div class="screen-content">
      <div id="start-intro-text"></div>
      <div id="start-logo"><img src="gfx-logo.png" class="logo-image"></div>
      <button id="start-btn">Starta</button>
    </div>
  </div>

  <!-- Player select -->
  <div id="select-screen" class="screen">
    <div class="screen-content">
      <div id="select-title">Välj spelare</div>
      <div class="player-options">
        <button class="player-choice" data-player="mattias">
          <img src="gfx-mattias.png"><span>Mattias</span>
        </button>
        <button class="player-choice" data-player="per">
          <img src="gfx-per.png"><span>Per</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Game over -->
  <div id="message" class="screen">
    <div class="screen-content">
      <div id="message-text"></div>
      <button id="restart-btn">Spela igen</button>
    </div>
  </div>

  <!-- Sound effects -->
  <audio id="oneup-sound" src="1up.mp3" preload="auto"></audio>
  <audio id="boom-sound" src="boom.mp3" preload="auto"></audio>
  <audio id="gameover-sound" src="gameover.mp3" preload="auto"></audio>
  <audio id="gameplay-music" src="gameplay.mp3" preload="auto" loop></audio>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    // Prevent long-press context menu / text selection behavior
    document.addEventListener('contextmenu', (e) => e.preventDefault());
    document.addEventListener('selectstart', (e) => e.preventDefault());

    const scoreNumberEl = document.getElementById("score-number");
    const livesEl = document.getElementById("lives");
    const messageEl = document.getElementById("message");
    const messageTextEl = document.getElementById("message-text");

    const startScreenEl = document.getElementById("start-screen");
    const selectScreenEl = document.getElementById("select-screen");
    const startBtn = document.getElementById("start-btn");
    const restartBtn = document.getElementById("restart-btn");
    const playerChoiceButtons = document.querySelectorAll(".player-choice");

    const startLogoEl = document.getElementById("start-logo");
    const startIntroEl = document.getElementById("start-intro-text");
    const bgFadeEl = document.getElementById("bg-fade");

    const oneUpSound  = document.getElementById("oneup-sound");
    const boomSound   = document.getElementById("boom-sound");
    const gameoverSound = document.getElementById("gameover-sound");
    const gameplayMusic = document.getElementById("gameplay-music");

    const GAME_WIDTH = 360;
    const GAME_HEIGHT = 640;

    /* Fullscreen Canvas – fill entire screen (non-uniform scale) */
    function resize() {
      const w = window.innerWidth;
      const h = window.innerHeight;

      canvas.style.width = w + "px";
      canvas.style.height = h + "px";

      canvas.width = w;
      canvas.height = h;

      const scaleX = w / GAME_WIDTH;
      const scaleY = h / GAME_HEIGHT;
      ctx.setTransform(scaleX, 0, 0, scaleY, 0, 0);
    }
    window.addEventListener("resize", resize);
    resize();

    /* Images */
    const playerMattiasImg = new Image();
    playerMattiasImg.src = "gfx-mattias.png";
    const playerPerImg = new Image();
    playerPerImg.src = "gfx-per.png";

    let currentPlayerImg = playerMattiasImg;

    const bunImg = new Image();
    bunImg.src = "gfx-lussekatt.png";
    const enemyImg = new Image();
    enemyImg.src = "gfx-brand.png";
    const bgImg = new Image();
    bgImg.src = "gfx-lundbergs.png";

    /* Santa & Lucia */
    const santaImg = new Image();
    santaImg.src = "gfx-santa.png";

    const luciaImg = new Image();
    luciaImg.src = "gfx-lucia.png";

    const SANTA_SCALE = 0.25;
    let SANTA_WIDTH = 0;
    let SANTA_HEIGHT = 0;

    santaImg.onload = () => {
      SANTA_WIDTH = santaImg.width * SANTA_SCALE;
      SANTA_HEIGHT = santaImg.height * SANTA_SCALE;
    };

    let santa = {
      active: false,
      img: santaImg,
      x: 0,
      y: 0,
      speed: 80
    };
    let santaTimer = 0;
    let nextSantaTime = 4 + Math.random()*8;

    /* Stars (background) */
    const STAR_COUNT = 40;
    let stars = [];

    function initStars() {
      stars = [];
      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push({
          x: Math.random() * GAME_WIDTH,
          y: Math.random() * GAME_HEIGHT,
          phase: Math.random() * Math.PI * 2,
          speed: 0.5 + Math.random() * 0.8
        });
      }
    }

    function updateStars(dt) {
      for (let s of stars) {
        s.phase += s.speed * dt;
      }
    }

    function drawStars() {
      for (let s of stars) {
        const b = 0.2 + 0.8 * (0.5 + 0.5 * Math.sin(s.phase));
        ctx.fillStyle = `rgba(255,255,255,${b})`;
        ctx.fillRect(s.x, s.y, 2, 2);
      }
    }

    /* Crumbs */
    let crumbs = [];
    function spawnCrumbs(x,y,color){
      for(let i=0;i<8;i++){
        crumbs.push({
          x,
          y,
          vx:(Math.random()-0.5)*120,
          vy:(Math.random()-0.5)*120,
          life:0.6+Math.random()*0.3,
          color
        });
      }
    }

    function updateCrumbs(dt) {
      for (let c of crumbs) {
        c.x += c.vx * dt;
        c.y += c.vy * dt;
        c.life -= dt;
      }
      crumbs = crumbs.filter(c => c.life > 0);
    }

    /* Music helpers */
    function startGameplayMusic() {
      gameplayMusic.volume = 0.8;
      gameplayMusic.currentTime = 0;
      gameplayMusic.play().catch(() => {});
    }

    function stopGameplayMusic() {
      gameplayMusic.pause();
      gameplayMusic.currentTime = 0;
    }

    /* Game state */
    let lastTime = 0;
    let player;
    let obstacles;
    let score;
    let lives;
    let timeAlive;

    let spawnTimer = 0;
    let spawnInterval = 1.0;

    let holdingLeft = false;
    let holdingRight = false;

    const PLAYER_SPEED = 220;

    // states: "start", "intro", "select", "playing", "gameover"
    let gameState = "start";

    /* Intro sequence */
    const introLines = [
      "Adventsmorgon i Gröndal.",
      "På Lundbergs bakas det för fullt.",
      "Hjälp till att fånga de nybakade lussekatterna.",
      "Men akta dig för de vidbrända."
    ];

    function playIntroSequence() {

      gameState = "intro";
      startScreenEl.style.display = "flex";
      selectScreenEl.style.display = "none";
      document.getElementById("overlay").style.display = "none";
      messageEl.style.display = "none";

      startIntroEl.innerHTML = "";
      startIntroEl.style.display = "block";

      // Hide logo + button instantly
      startLogoEl.style.display = "none";
      startBtn.style.display = "none";

      const lineDelay = 2800;

      introLines.forEach((text, idx) => {
        const p = document.createElement("p");
        p.textContent = text;
        p.className = "intro-line";
        startIntroEl.appendChild(p);

        setTimeout(() => {
          p.classList.add("visible");

          if (idx === introLines.length - 1) {
            setTimeout(() => {
              setGameState("select");
            }, 5000);
          }
        }, idx * lineDelay);
      });
    }

    function updateLivesUI(){
      livesEl.innerHTML="";
      for(let i=0;i<lives;i++){
        const img = document.createElement("img");
        img.src="gfx-heart.png";
        livesEl.appendChild(img);
      }
    }

    function resetGame(){
      player = {
        x: GAME_WIDTH/2,
        y: GAME_HEIGHT-55,
        width: 70,
        height: 110
      };

      obstacles=[];
      score=0;
      lives=3;
      timeAlive=0;
      spawnTimer=0;

      crumbs = [];

      updateLivesUI();
      scoreNumberEl.textContent=score;
      initStars();

      messageEl.style.display="none";
    }

    /* Start screen animation sequence:
       1) Tone in background (bg-fade goes from 1 -> 0)
       2) Logo left-to-right reveal
       3) Start button fade-in
    */
    function runStartScreenAnimations() {
      // Reset logo animation state
      document.body.classList.remove('logo-anim');
      startBtn.classList.remove('show');

      // Reset bg fade to opaque then fade out
      bgFadeEl.classList.remove('hidden');
      // force reflow so the transition always runs
      void bgFadeEl.offsetWidth;
      bgFadeEl.classList.add('hidden');

      // Start logo reveal slightly after fade begins
      setTimeout(() => {
        document.body.classList.add('logo-anim');
      }, 400);

      // Start button fade-in after logo reveal
      setTimeout(() => {
        startBtn.classList.add('show');
      }, 800);
    }

    /* Screen switching */
    function setGameState(state){
      gameState = state;

      /* Start + intro screens */
      startScreenEl.style.display =
        (state === "start" || state === "intro") ? "flex" : "none";

      /* Player select screen with fade-in */
      if (state === "select") {
        selectScreenEl.style.display = "flex";
        selectScreenEl.classList.remove("visible");
        setTimeout(() => {
          selectScreenEl.classList.add("visible");
        }, 50);
      } else {
        selectScreenEl.classList.remove("visible");
        selectScreenEl.style.display = "none";
      }

      /* HUD visible during playing and gameover */
      document.getElementById("overlay").style.display =
        (state === "playing" || state === "gameover") ? "flex" : "none";

      if (state !== "gameover") {
        messageEl.style.display = "none";
      }

      if (state === "start") {
        startIntroEl.style.display = "none";
        startIntroEl.innerHTML = "";
        startLogoEl.style.display = "block";
        startBtn.style.display = "inline-block";

        // re-run the frontpage animation whenever we return to start
        runStartScreenAnimations();
      }
    }

    function spawnObstacle(){
      const enemy = Math.random() < 0.2;
      obstacles.push({
        x:Math.random()*(GAME_WIDTH-28),
        y:-28,
        width:28,
        height:28,
        speed:120+Math.random()*60,
        type: enemy?"enemy":"bun"
      });
    }

    function hitOverlap(p,o){
      const w=p.width*0.6;
      const h=p.height*0.7;
      const x=p.x-w/2;
      const y=p.y-h/2;
      return !(x+w<o.x||x>o.x+o.width||y+h<o.y||y>o.y+o.height);
    }

    function endGame(){
      gameState="gameover";

      stopGameplayMusic();

      gameoverSound.currentTime=0;
      gameoverSound.play();

      // Explode all remaining buns/enemies into crumbs
      for (let o of obstacles) {
        const cx = o.x + o.width / 2;
        const cy = o.y + o.height / 2;
        const color = (o.type === "bun") ? "orange" : "brown";
        spawnCrumbs(cx, cy, color);
      }
      obstacles = []; // remove them from screen

      // Hide game over UI for a short while so crumbs can animate
      messageEl.style.display = "none";

      setTimeout(() => {
        // Only show if we're still in gameover (not restarted already)
        if (gameState === "gameover") {
          messageTextEl.innerHTML = `Du lyckades fånga<br>${score} lussekatter`;
          messageEl.style.display="flex";
        }
      }, 900); // delay so crumbs can crumble
    }

    /* Santa / Lucia fly-by */
    function updateSanta(dt){
      if (!(gameState==="start"||gameState==="intro"||gameState==="select")){
        santa.active=false;
        return;
      }

      if(!santa.active){
        santaTimer += dt;
        if(santaTimer >= nextSantaTime){
          // Pick Santa OR Lucia randomly
          const chosenImg = (Math.random() < 0.5 ? santaImg : luciaImg);
          santa.img = chosenImg;

          const w = chosenImg.width ? chosenImg.width * SANTA_SCALE : 80;
          const h = chosenImg.height ? chosenImg.height * SANTA_SCALE : 32;

          SANTA_WIDTH = w;
          SANTA_HEIGHT = h;

          santa.active = true;
          santa.x = GAME_WIDTH + w;
          santa.y = GAME_HEIGHT - 20 - h; /* 20px above bottom */
          santaTimer = 0;
          nextSantaTime = 4 + Math.random()*8;
        }
      } else {
        santa.x -= santa.speed * dt;
        const w = SANTA_WIDTH || 80;
        if(santa.x < -w - 20) {
          santa.active = false;
        }
      }
    }

    /* Gameplay – with crumbs, but no catch-sound */
    function updateGame(dt){
      timeAlive+=dt;
      const difficulty = Math.min(timeAlive/30,1);
      spawnInterval = 1.0 - difficulty*0.6;

      if(holdingLeft&&!holdingRight)  player.x-=PLAYER_SPEED*dt;
      if(holdingRight&&!holdingLeft) player.x+=PLAYER_SPEED*dt;

      const half=player.width/2;
      if(player.x<half) player.x=half;
      if(player.x>GAME_WIDTH-half) player.x=GAME_WIDTH-half;

      // Spawn (dt-safe)
      spawnTimer += dt;
      if(spawnTimer >= spawnInterval){
        spawnTimer -= spawnInterval;
        spawnObstacle();
      }

      const speedBoost = 120 + (420-120)*difficulty;

      // Single pass: move + collide + keep/kill
      let writeIndex = 0;
      for (let i = 0; i < obstacles.length; i++) {
        const o = obstacles[i];

        // Move obstacle
        o.y += (o.speed + speedBoost*0.5)*dt;

        let remove = false;

        // Collision with player
        if (hitOverlap(player, o)){
          const cx = o.x + o.width/2;
          const cy = o.y + o.height/2;

          if(o.type==="bun"){
            score++;
            scoreNumberEl.textContent=score;

            // orange crumbs on catch
            spawnCrumbs(cx, cy, "orange");

            if(score%10===0){
              lives++;
              oneUpSound.currentTime=0;
              oneUpSound.play();
              updateLivesUI();
            }
          } else {
            // enemy hit: lose life + boom + brown crumbs
            lives--;
            boomSound.currentTime=0;
            boomSound.play();
            updateLivesUI();

            spawnCrumbs(cx, cy, "brown");

            if(lives<=0){
              endGame();
              return; // stop processing this frame
            }
          }

          remove = true;
        }
        // Missed bun off-screen -> life lost + brown crumbs, but NO sound
        else if (o.y > GAME_HEIGHT) {
          if(o.type==="bun"){
            lives--;

            // spawn brown crumbs at bottom-ish position
            const cxBottom = o.x + o.width/2;
            const cyBottom = GAME_HEIGHT - 5;
            spawnCrumbs(cxBottom, cyBottom, "brown");

            updateLivesUI();
            if(lives<=0){
              endGame();
              return;
            }
          }
          remove = true;
        }

        // Keep obstacle if not removed
        if (!remove) {
          obstacles[writeIndex++] = o;
        }
      }
      obstacles.length = writeIndex;
    }

    function draw(){
      ctx.clearRect(0,0,GAME_WIDTH,GAME_HEIGHT);

      if(bgImg.complete){
        const scale=GAME_WIDTH/bgImg.width;
        const h=bgImg.height*scale;
        const y=GAME_HEIGHT-h;
        if(y>0){
          ctx.fillStyle="#050711";
          ctx.fillRect(0,0,GAME_WIDTH,y);
        }
        ctx.drawImage(bgImg,0,y,GAME_WIDTH,h);
      }

      // Starry background on all screens
      drawStars();

      if((gameState==="start"||gameState==="intro"||gameState==="select")&&santa.active){
        const w = SANTA_WIDTH || santa.img.width * SANTA_SCALE || 80;
        const h = SANTA_HEIGHT || santa.img.height * SANTA_SCALE || 32;
        ctx.drawImage(santa.img,santa.x,santa.y,w,h);
      }

      // Draw crumbs as pixel chunks
      for(let c of crumbs){
        ctx.fillStyle = c.color==="orange" ? "#ffb746" : "#8c5a32";
        ctx.fillRect(Math.round(c.x),Math.round(c.y),3,3);
      }

      // Draw player in both playing and gameover
      if(gameState==="playing" || gameState==="gameover"){
        ctx.drawImage(currentPlayerImg,
          player.x-player.width/2,
          player.y-player.height/2,
          player.width,player.height
        );
      }

      // Draw buns only while playing
      if(gameState==="playing"){
        for(let o of obstacles){
          const img=(o.type==="enemy")?enemyImg:bunImg;
          ctx.drawImage(img,o.x,o.y,o.width,o.height);
        }
      }
    }

    function loop(t){
      const dt=(t-lastTime)/1000||0;
      lastTime=t;

      updateStars(dt);
      updateSanta(dt);
      updateCrumbs(dt);   // <- crumbs now animate in all states

      if(gameState==="playing"){
        updateGame(dt);
      }

      draw();
      requestAnimationFrame(loop);
    }

    /* Controls */
    canvas.addEventListener("pointerdown",e=>{
      const rect = canvas.getBoundingClientRect();
      const xGame = (e.clientX - rect.left) / rect.width * GAME_WIDTH;

      holdingLeft = (xGame < GAME_WIDTH/2);
      holdingRight = !holdingLeft;
    });

    window.addEventListener("pointerup",()=>{
      holdingLeft=false;
      holdingRight=false;
    });

    window.addEventListener("keydown",e=>{
      if(e.key==="ArrowLeft"||e.key==="a") holdingLeft=true;
      if(e.key==="ArrowRight"||e.key==="d") holdingRight=true;
      if(e.key===" "&&gameState==="gameover"){
        resetGame();
        setGameState("select");
      }
    });

    window.addEventListener("keyup",e=>{
      if(e.key==="ArrowLeft"||e.key==="a") holdingLeft=false;
      if(e.key==="ArrowRight"||e.key==="d") holdingRight=false;
    });

    restartBtn.addEventListener("click",()=>{
      resetGame();
      setGameState("select");
    });

    startBtn.addEventListener("click",()=>{
      playIntroSequence();
    });

    playerChoiceButtons.forEach(btn=>{
      btn.addEventListener("click",()=>{
        currentPlayerImg =
          btn.dataset.player==="per" ? playerPerImg : playerMattiasImg;
        resetGame();
        setGameState("playing");
        startGameplayMusic();
      });
    });

    /* Begin */
    resetGame();
    setGameState("start");
    requestAnimationFrame(loop);

  </script>
</body>
</html>
